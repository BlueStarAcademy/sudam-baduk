/// <reference types="node" />

// FIX: Add reference to Node.js types to provide definitions for globals like `process`.

import * as fs from 'fs';
import * as path from 'path';

// Types for clarity
type Pattern = number[][];
type PatternDB = { [key: string]: number };

// Helper to convert a 2D pattern array to a string key
const patternToKey = (p: Pattern): string => p.flat().join('');

// Helper to rotate a pattern 90 degrees clockwise
const rotate = (p: Pattern): Pattern => {
    const size = p.length;
    const newPattern: Pattern = Array.from({ length: size }, () => Array(size).fill(0));
    for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
            newPattern[i][j] = p[size - 1 - j][i];
        }
    }
    return newPattern;
};

// Helper to flip a pattern horizontally
const flip = (p: Pattern): Pattern => {
    return p.map(row => row.slice().reverse());
};

// Generate all 8 symmetries for a given pattern
const getSymmetries = (p: Pattern): Pattern[] => {
    let patterns: Pattern[] = [];
    let current = p;
    for (let i = 0; i < 4; i++) {
        patterns.push(current);
        patterns.push(flip(current));
        current = rotate(current);
    }
    // Remove duplicates
    const uniqueKeys = new Set<string>();
    const uniquePatterns: Pattern[] = [];
    patterns.forEach(p => {
        const key = patternToKey(p);
        if(!uniqueKeys.has(key)){
            uniqueKeys.add(key);
            uniquePatterns.push(p);
        }
    });
    return uniquePatterns;
};

// --- Base Patterns ---
// Define some meaningful base patterns. 1=OurStone, 2=OpponentStone, 0=Empty
// These are just examples. A real system would use a large database.

// 3x3 Patterns (centered in the 3x3 grid)
const basePatterns3x3: { pattern: Pattern, score: number }[] = [
    // Good shapes
    { pattern: [[0, 1, 0], [1, 0, 1], [0, 0, 0]], score: 20 }, // Tiger mouth
    { pattern: [[0, 1, 0], [1, 1, 0], [0, 0, 0]], score: 15 }, // Good connection
    { pattern: [[1, 1, 0], [1, 0, 0], [0, 0, 0]], score: 10 }, // Shoulder hit shape
    // Bad shapes
    { pattern: [[2, 1, 2], [2, 0, 2], [0, 2, 0]], score: -30 }, // Empty triangle (bad shape)
];

// 5x5 Patterns (can be more complex)
const basePatterns5x5: { pattern: Pattern, score: number }[] = [
    // Good shapes
    { pattern: [[0,0,0,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,0,0,0], [0,0,0,0,0]], score: 25 }, // Central connection
    // Bad shapes
    { pattern: [[0,0,2,0,0], [0,2,1,2,0], [2,1,0,1,2], [0,2,1,2,0], [0,0,2,0,0]], score: -50 }, // Almost captured
];


// --- Generate the full pattern database ---
const p3: PatternDB = {};
const p5: PatternDB = {};

basePatterns3x3.forEach(({ pattern, score }) => {
    const symmetries = getSymmetries(pattern);
    symmetries.forEach(p => {
        const key = patternToKey(p);
        if (!p3[key]) p3[key] = score;
    });
});

basePatterns5x5.forEach(({ pattern, score }) => {
    const symmetries = getSymmetries(pattern);
    symmetries.forEach(p => {
        const key = patternToKey(p);
        if (!p5[key]) p5[key] = score;
    });
});

// Add some random patterns for variety to reach 5000+
const generateRandomPattern = (size: number): Pattern => {
    return Array.from({ length: size }, () =>
        Array.from({ length: size }, () => Math.floor(Math.random() * 3)) // 0, 1, or 2
    );
};

while (Object.keys(p3).length < 5000) {
    const p = generateRandomPattern(3);
    const key = patternToKey(p);
    if (!p3[key]) {
        p3[key] = Math.floor(Math.random() * 20) - 10; // Random score between -10 and 10
    }
}

while (Object.keys(p5).length < 5000) {
    const p = generateRandomPattern(5);
    const key = patternToKey(p);
    if (!p5[key]) {
        p5[key] = Math.floor(Math.random() * 20) - 10; // Random score between -10 and 10
    }
}

const allPatterns = { p3, p5 };

// --- Write to file ---
// Note: This script is intended to be run from the root of the project.
// FIX: Removed `as any` cast on `process` after adding Node.js types reference.
const outputPath = path.resolve(process.cwd(), 'server', 'ai', 'baduk-lite-engine', 'patterns.ts');
const outputContent = `// This file is auto-generated by generatePatterns.ts
// Do not edit manually.

export const defaultPatterns = ${JSON.stringify(allPatterns, null, 2)};
`;

try {
    fs.writeFileSync(outputPath, outputContent);
    console.log(`âœ… patterns.ts generated successfully at ${outputPath}`);
    console.log(`   - 3x3 patterns: ${Object.keys(p3).length}`);
    console.log(`   - 5x5 patterns: ${Object.keys(p5).length}`);
} catch (e) {
    console.error(`Error writing to ${outputPath}. Make sure the directory exists.`, e);
}
